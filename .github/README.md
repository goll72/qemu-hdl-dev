qemu-hdl-dev
============

qemu-hdl-dev is a patch to allow USB, PCI, PS/2 and serial devices
described in Verilog/SystemVerilog to be used with QEMU.

## Usage

You will need to compile your design to C++ using Verilator, link
the generated object files alongside the corresponding C++ file for
the protocol being used, generating a shared library, and then load
the shared library with QEMU, instantiating the proper device. You
will have to use the options `--timing` and `--pins-inout-enables`.

After verilating your HDL files and generating the object files, they
can be linked to generate a shared library by running a command line
similar to the following:

```sh
c++ -std=c++20 -fPIC -shared \
    -I ${VERILATOR_ROOT}/include -I ${VERILATOR_ROOT}/include/vltstd \
    -I ${HDL_DEV_ROOT}/client/include -I . \
    -DTOP=V${TOP} -DTOP_HEADER=\"${OBJDIR}/V${TOP}.h\" \
    ${OBJDIR}/verilated.o \
    ${OBJDIR}/verilated_threads.o \
    ${OBJDIR}/verilated_timing.o \
    ${OBJDIR}/V${TOP}__ALL.o \
    ${HDL_DEV_ROOT}/client/${PROTO}.cpp \
    -o ${TOP}.so
```

`TOP` and `TOP_HEADER` have to be defined. `TOP` is the class generated
by Verilator for the top-level entity and `TOP_HEADER` is the
corresponding header file, also generated by Verilator. `HDL_DEV_ROOT`
is this repository's root.

## Interface

The following sections specify the Verilog module interface needed for
each protocol type. The port names and types must match the ones shown
for `qemu-hdl-dev` to work, but extra ports can be added (you will need
to modify the provided C++ file(s) with custom logic for these ports to
be useful).

Note that the way Verilator implements inout pins does not allow the
simulation to tell if an input value is being driven from C++ or not,
so a `_dir` input pin is added where needed, where `1` will correspond
to output (not being driven by C++) and `0` will correspond to input.

This also means that a value being driven by the simulation on an
inout port can't be read back by the simulation by default (see
[this issue](https://redirect.github.com/verilator/verilator/issues/5541)).
In that case, you should use an internal signal instead.

### PS/2

```systemverilog
module top(
    input logic clk_dir,
    inout tri1 clk,
    input logic data_dir,
    inout tri1 data
);

// ...

endmodule
```

Both `clk` and `data` are connected to pull-up resistors and should
never be driven a high logic output value.

For now, a PS/2 keyboard/mouse can only be instantiated in x86, by passing
the optional string properties `hdl-kbd` and `hdl-mouse` to the `pc` machine.
The value of the property should be a shared library path for the HDL device.

### USB

```systemverilog
module top(
    // D+
    input logic d_p_dir,
    inout logic d_p,
    // D-
    input logic d_m_dir,
    inout logic d_m
);

// ...

endmodule
```

## Internals

The implementation is split in two parts:

  - The QEMU code, which is responsible for instantiating a device,
    loading the shared library, stepping the simulation at the
    proper time intervals and piecing together the bits in the
    "wire format" into the higher level format that QEMU uses
    (and vice versa).

  - The "client" code, comprised of the simulation itself and the
    C++ files in the `client` directory, which must export the
    functions defined and documented in `hdl-dev/verilated.h`.

    There is a protocol-specific symbol that must be exported, which
    is checked by the QEMU code to prevent accidental loading of a
    library for a device using a different protocol. The names of
    these symbols are listed in `hdl-dev/common.h`.

    If you want to instantiate multiple HDL devices at once, you
    should make sure they share the same `VerilatedContext`, since
    that will allow their simulation times to be kept properly
    synchronized and will also allow direct cross-communication
    between devices by using hierarchical names.

    Since the smallest possible granularity for a QEMU timer is one
    nanosecond, 1 GHz is the maximum possible frequency for data
    transfer between an HDL device and QEMU, so `timeprecision`
    values smaller than -9 will just result on the QEMU code calling
    `hdl_dev_step` repeatedly without updating inputs/outputs.

    If a `timeprecision` smaller than -9 is desired for internal
    use but only by a single device, it can be accomplished by
    making it use a separate `VerilatedContext`, but care must be
    taken: namely, `hdl_dev_timeprecision` should "lie" about the
    `timeprecision` value, reporting a value equal to the
    `timeprecision` value of the other devices, while only one of
    the stages in `hdl_dev_step` is actually used to do all of the
    stepping by the proper number of time units, so that a value
    corresponding to the reported `timeprecision` value ends up
    being stepped.

## Notes

 - Migrations are not supported, as Verilator doesn't support
   save/restore alongside `--timing`.
